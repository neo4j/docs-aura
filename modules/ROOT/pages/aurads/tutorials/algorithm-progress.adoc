[[algorithm-progress]]
= Algorithm progress
:description: This page describes how to use monitor the algorithm progress.
:generated-graph-size: 1000000

WARNING: The graph size here is different from the existing example (1M instead of 10M) to make it faster. Is it an issue?

TIP: Follow along with a notebook in https://colab.research.google.com/drive/1cz5o6LaEh7m3qsyO5ORBJGk7C-pfbq69?usp=sharing[image:colab.svg[Colab,24] Google Colab^]

This brief tutorial can be followed within a Google Colab which is based on Jupyter notebooks.

Running algorithms on large graphs can be computationally expensive. As part of your workflow, you may want to chain algorithms together, inspect the progress of each step and potentially export the results to other systems or workflows.

Understanding when an algorithm has completed is especially useful in the above application.

In this tutorial, you will be shown how to use and interpret the `gds.beta.listProgress()` procedure, along with integrating it as part of your workflow.

For more information about https://neo4j.com/docs/graph-data-science/current/common-usage/logging/#logging-progress-logging[Progress Logging] head over to the Neo4j Graph Data Science Library manual.

include::partial$aurads/setup.adoc[]

include::partial$aurads/generated-graph.adoc[]

== Checking progress Long running algorithms

We will need to start a long running algorithm that will take a little while to converge. For our example we'll try `Label Propagation` which will take some time.

In order to be able to start a long running query and inspect the progress we will use threading in this example.

[.tabbed-example]
====
[.include-with-GDS-client]
=====
[source, python, subs=attributes+]
----
# Imports to help us
import threading, time


# method to call label propagation on our example in memory graph
def run_label_prop():
  result = gds.labelPropagation.mutate(
    g,
    mutateProperty="communityID"
  )

  print(json.dumps(result, indent=2, sort_keys=True))

def run_list_progress():
  result = gds.beta.listProgress()

  print(json.dumps(result, indent=2, sort_keys=True, default=default))

# create a thread for each of the cypher calls
label_prop_query_thread = threading.Thread(target=run_label_prop)
list_progress_query_thread = threading.Thread(target=run_list_progress)

# start the label propagation query
label_prop_query_thread.start()

# sleep for a few seconds so the label propagation query has time to get going
print('sleeping for 5 seconds')
time.sleep(5)
# start the list progress query
list_progress_query_thread.start()

# block and wait for the threads to finish
list_progress_query_thread.join()
label_prop_query_thread.join()
----
=====

[.include-with-Cypher]
=====
[source, cypher, subs=attributes+]
----
CALL gds.labelPropagation.mutate(
  'example-graph', 
  {mutateProperty: 'communityID'}
)
YIELD preProcessingMillis,
  computeMillis,
  mutateMillis,
  postProcessingMillis,
  nodePropertiesWritten,
  communityCount,
  ranIterations,
  didConverge,
  communityDistribution,
  configuration
RETURN *

// Run the following query in another Cypher shell, i.e. run this command
// in a different terminal first:
//
// ./cypher-shell -a $AURA_CONNECTION_URI -u $AURA_USERNAME -p $AURA_PASSWORD

CALL gds.beta.listProgress()
YIELD jobId, taskName, progress, progressBar
RETURN *
----
=====

[.include-with-Python-driver]
=====
[source, python, subs=attributes+]
----
# Imports to help us
import threading, time


# method to call label propagation on our example in memory graph
def run_label_prop():
  label_prop_mutate_example_graph_query = """
  CALL gds.labelPropagation.mutate(
    'example-graph', 
    {mutateProperty: 'communityID'}
  )
  YIELD preProcessingMillis,
    computeMillis,
    mutateMillis,
    postProcessingMillis,
    nodePropertiesWritten,
    communityCount,
    ranIterations,
    didConverge,
    communityDistribution,
    configuration
  RETURN *
  """

  # Create driver session
  with driver.session() as session:
    # Run query
    print('running label prop')
    results = session.run(label_prop_mutate_example_graph_query).data()
    # Prettify the first result
    print(json.dumps(results[0], indent=2, sort_keys=True))


# method to call list progress which calls
def run_list_progress():
  gds_list_progress_query = """
  CALL gds.beta.listProgress()
  YIELD jobId, taskName, progress, progressBar
  RETURN *
  """

  # Create driver session
  with driver.session() as session:
    # Run query
    print('running list progress')
    results = session.run(gds_list_progress_query).data()
    # Prettify the first result
    print('list progress results: ')
    print(json.dumps(results[0], indent=2, sort_keys=True))


# create a thread for each of the cypher calls
label_prop_query_thread = threading.Thread(target=run_label_prop)
list_progress_query_thread = threading.Thread(target=run_list_progress)

# start the label propagation query
label_prop_query_thread.start()

# sleep for a few seconds so the label propagation query has time to get going
print('sleeping for 5 seconds')
time.sleep(5)
# start the list progress query
list_progress_query_thread.start()

# block and wait for the threads to finish
list_progress_query_thread.join()
label_prop_query_thread.join()
----
=====
====

== Clean-up the tutorial

To drop the example in-memory graph we created previously, you can use the `gds.graph.drop` procedure and specify the name of the graph we created (example-graph).

https://neo4j.com/docs/graph-data-science/current/management-ops/graph-catalog-ops/#graph-catalog-ops[]

[.tabbed-example]
====
[.include-with-GDS-client]
=====
[source, python, subs=attributes+]
----
result = gds.graph.drop(g)

print(json.dumps(result, indent=2, sort_keys=True, default=default))
----
=====

[.include-with-Cypher]
=====
[source, cypher, subs=attributes+]
----
CALL gds.graph.drop('example-graph')
----
=====

[.include-with-Python-driver]
=====
[source, python, subs=attributes+]
----
delete_example_in_memory_graph_query = """
CALL gds.graph.drop('example-graph')
"""

with driver.session() as session:
  # Run query
  results = session.run(delete_example_in_memory_graph_query).data()

  # Prettify the results
  print(json.dumps(results, indent=2, sort_keys=True, default=default))
----
=====
====
