[[memory-estimation]]
= Estimating memory and resizing an instance
:description: This page describes how to use estimate the needed memory.
:generated-graph-size: 50000000

TIP: Follow along with a notebook in https://colab.research.google.com/drive/1C-GNnSFlWmxFGe-AN193jix_srAmb-c_?usp=sharing[image:colab.svg[Colab,24] Google Colab^]

In this tutorial, we will show you how to use the memory estimator for algorithms and how to resize your instance if needed in order to run your desired algorithm.

For more information about https://neo4j.com/docs/graph-data-science/current/common-usage/memory-estimation/[memory estimation] head over to the Neo4j Graph Data Science Library manual.

include::partial$aurads/setup.adoc[]

include::partial$aurads/generated-graph.adoc[]

NOTE: The graph is fairly large, so the generation procedure will take a few minutes to complete.

== Estimate

It can be useful to get a memory estimation to understand the impact an algorithm will have (running on the in-memory graph you provided given the available compute resources), before running any of the `Stream`, `Mutate` or `Write` execution modes.

The Graph Data Science Library does have guard-rails built in, so if an algorithm uses more than the RAM & CPU you have available you will get an exception returned.

If you need more RAM & CPU, you can resize your GDS instance within the Neo4j Aura Console under the Settings tab under the instance details.

Below is an example of getting a memory estimation for if we wanted to mutate the in-memory graph with the results of PageRank. The estimated required memory is between 381 MiB and 4477 MiB, which is higher than an 8GB instance has available (4004 MiB).

[.tabbed-example]
====
[.include-with-GDS-client]
=====
[source, python, subs=attributes+]
----
result = gds.labelPropagation.mutate.estimate(
  g,
  mutateProperty="communityID"
)

# Print prettified estimation information
print(json.dumps(result, indent=2, sort_keys=True))
----
=====

[.include-with-Cypher]
=====
[source, cypher, subs=attributes+]
----
CALL gds.labelPropagation.mutate.estimate(
  'example-graph',
  {mutateProperty: 'communityID'}
)
YIELD nodeCount,
  relationshipCount,
  bytesMin,
  bytesMax,
  requiredMemory
RETURN *
----
=====

[.include-with-Python-driver]
=====
[source, python, subs=attributes+]
----
# Cypher query
page_rank_mutate_estimate_example_graph_query = """
CALL gds.labelPropagation.mutate.estimate(
  'example-graph',
  {mutateProperty: 'communityID'}
)
YIELD nodeCount,
  relationshipCount,
  bytesMin,
  bytesMax,
  requiredMemory
RETURN *
"""

# Create driver session
with driver.session() as session:
  # Run query
  results = session.run(page_rank_mutate_estimate_example_graph_query).data()
  # Prettify the first result
  print(json.dumps(results[0], indent=2, sort_keys=True))
----
=====
====

The `mutate` procedure hits the guard rails on an 8GB instance, raising an exception that suggests to resize the AuraDS instance.

[.tabbed-example]
====
[.include-with-GDS-client]
=====
[source, python, subs=attributes+]
----
result = gds.labelPropagation.mutate(
  g,
  mutateProperty="communityID"
)

print(json.dumps(result, indent=2, sort_keys=True))
----
=====

[.include-with-Cypher]
=====
[source, cypher, subs=attributes+]
----
CALL gds.labelPropagation.mutate(
  'example-graph', 
  {mutateProperty: 'communityID'}
)
YIELD preProcessingMillis,
  computeMillis,
  mutateMillis,
  postProcessingMillis,
  nodePropertiesWritten,
  communityCount,
  ranIterations,
  didConverge,
  communityDistribution,
  configuration
RETURN *
----
=====

[.include-with-Python-driver]
=====
[source, python, subs=attributes+]
----
# Lets try to run the query to hit the memory guard

# Cypher query
page_rank_mutate_example_graph_query = """
CALL gds.labelPropagation.mutate(
  'example-graph', 
  {mutateProperty: 'communityID'}
)
YIELD preProcessingMillis,
  computeMillis,
  mutateMillis,
  postProcessingMillis,
  nodePropertiesWritten,
  communityCount,
  ranIterations,
  didConverge,
  communityDistribution,
  configuration
RETURN *
"""

# Create driver session
with driver.session() as session:
  # Run query
  results = session.run(page_rank_mutate_example_graph_query).data()
  # Prettify the first result
  print(json.dumps(results[0], indent=2, sort_keys=True))
----
=====
====

== Resizing your instance

Resizing your instance will incur a short amount of downtime.

Click the name of your instance on the home to get to the instance details.

image::resize1.png[title="Resize 1"]

Under the settings tab, after clicking the resize option you can select a new instance size which matches the required memory needed given by the previous estimation.

image::resize2.png[title="Resize 2"]

After resizing is complete, wait a few seconds until the projected graph is loaded again and run again the `mutate` step. This time no exception is thrown and the step completes successfully.

== Clean-up the tutorial

To drop the example in-memory graph we created previously, you can use the https://neo4j.com/docs/graph-data-science/current/management-ops/graph-catalog-ops/#graph-catalog-ops[gds.graph.drop] procedure and specify the name of the graph we created (example-graph).

[.tabbed-example]
====
[.include-with-GDS-client]
=====
[source, python, subs=attributes+]
----
result = gds.graph.drop(g)

print(json.dumps(result, indent=2, sort_keys=True, default=default))
----
=====

[.include-with-Cypher]
=====
[source, cypher, subs=attributes+]
----
CALL gds.graph.drop('example-graph')
----
=====

[.include-with-Python-driver]
=====
[source, python, subs=attributes+]
----
delete_example_in_memory_graph_query = """
CALL gds.graph.drop('example-graph')
"""

with driver.session() as session:
  # Run query
  results = session.run(delete_example_in_memory_graph_query).data()

  # Prettify the results
  print(json.dumps(results, indent=2, sort_keys=True))
----
=====
====
