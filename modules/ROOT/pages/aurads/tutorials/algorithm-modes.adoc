[[algorithm-modes]]
= Executing the different algorithm modes
:description: This page describes how to use the different algorithm modes.
:generated-graph-size: 100

TIP: Follow along with a notebook in https://colab.research.google.com/drive/1n5RBKgZVpYmCVBkvOqwkO8qFGb2sqF3U?usp=sharing[image:colab.svg[Colab,24] Google Colab^]

This brief tutorial can be followed along within a Google Colab which is based on Jupyter notebooks.

Within this tutorial, we'll teach you about each of the algorithm execution modes, how you take advantage of them and the benefits they can provide.

For more information about the https://neo4j.com/docs/graph-data-science/current/common-usage/running-algos[Execution Modes], head over to the Neo4j Graph Data Science Library manual.

include::partial$aurads/setup.adoc[]

== Creating an example graph

We need to create some graph data first.

[.tabbed-example]
====
[.include-with-GDS-client]
=====
[source, python, subs=attributes+]
----
# Cypher query
create_example_graph_on_disk_query = """
CREATE
  (home:Page {name:'Home'}),
  (about:Page {name:'About'}),
  (product:Page {name:'Product'}),
  (links:Page {name:'Links'}),
  (a:Page {name:'Site A'}),
  (b:Page {name:'Site B'}),
  (c:Page {name:'Site C'}),
  (d:Page {name:'Site D'}),

  (home)-[:LINKS {weight: 0.2}]->(about),
  (home)-[:LINKS {weight: 0.2}]->(links),
  (home)-[:LINKS {weight: 0.6}]->(product),
  (about)-[:LINKS {weight: 1.0}]->(home),
  (product)-[:LINKS {weight: 1.0}]->(home),
  (a)-[:LINKS {weight: 1.0}]->(home),
  (b)-[:LINKS {weight: 1.0}]->(home),
  (c)-[:LINKS {weight: 1.0}]->(home),
  (d)-[:LINKS {weight: 1.0}]->(home),
  (links)-[:LINKS {weight: 0.8}]->(home),
  (links)-[:LINKS {weight: 0.05}]->(a),
  (links)-[:LINKS {weight: 0.05}]->(b),
  (links)-[:LINKS {weight: 0.05}]->(c),
  (links)-[:LINKS {weight: 0.05}]->(d)
"""

gds.run_cypher(create_example_graph_on_disk_query)
----
=====

[.include-with-Cypher]
=====
[source, cypher, subs=attributes+]
----
CREATE
  (home:Page {name:'Home'}),
  (about:Page {name:'About'}),
  (product:Page {name:'Product'}),
  (links:Page {name:'Links'}),
  (a:Page {name:'Site A'}),
  (b:Page {name:'Site B'}),
  (c:Page {name:'Site C'}),
  (d:Page {name:'Site D'}),

  (home)-[:LINKS {weight: 0.2}]->(about),
  (home)-[:LINKS {weight: 0.2}]->(links),
  (home)-[:LINKS {weight: 0.6}]->(product),
  (about)-[:LINKS {weight: 1.0}]->(home),
  (product)-[:LINKS {weight: 1.0}]->(home),
  (a)-[:LINKS {weight: 1.0}]->(home),
  (b)-[:LINKS {weight: 1.0}]->(home),
  (c)-[:LINKS {weight: 1.0}]->(home),
  (d)-[:LINKS {weight: 1.0}]->(home),
  (links)-[:LINKS {weight: 0.8}]->(home),
  (links)-[:LINKS {weight: 0.05}]->(a),
  (links)-[:LINKS {weight: 0.05}]->(b),
  (links)-[:LINKS {weight: 0.05}]->(c),
  (links)-[:LINKS {weight: 0.05}]->(d)
----
=====

[.include-with-Python-driver]
=====
[source, python, subs=attributes+]
----
# Cypher query
create_example_graph_on_disk_query = """
CREATE
  (home:Page {name:'Home'}),
  (about:Page {name:'About'}),
  (product:Page {name:'Product'}),
  (links:Page {name:'Links'}),
  (a:Page {name:'Site A'}),
  (b:Page {name:'Site B'}),
  (c:Page {name:'Site C'}),
  (d:Page {name:'Site D'}),

  (home)-[:LINKS {weight: 0.2}]->(about),
  (home)-[:LINKS {weight: 0.2}]->(links),
  (home)-[:LINKS {weight: 0.6}]->(product),
  (about)-[:LINKS {weight: 1.0}]->(home),
  (product)-[:LINKS {weight: 1.0}]->(home),
  (a)-[:LINKS {weight: 1.0}]->(home),
  (b)-[:LINKS {weight: 1.0}]->(home),
  (c)-[:LINKS {weight: 1.0}]->(home),
  (d)-[:LINKS {weight: 1.0}]->(home),
  (links)-[:LINKS {weight: 0.8}]->(home),
  (links)-[:LINKS {weight: 0.05}]->(a),
  (links)-[:LINKS {weight: 0.05}]->(b),
  (links)-[:LINKS {weight: 0.05}]->(c),
  (links)-[:LINKS {weight: 0.05}]->(d)
"""

# Create driver session
with driver.session() as session:
  # Run query
  result = session.run(create_example_graph_on_disk_query).data()
  # Prettify the first result
  print(json.dumps(result[0], indent=2, sort_keys=True))
----
=====
====

We then project an in-memory graph from the data just created.

[.tabbed-example]
====
[.include-with-GDS-client]
=====
[source, python, subs=attributes+]
----
g, result = gds.graph.project(
  "example_graph",
  "Page",
  "LINKS",
  relationshipProperties="weight"
)

print(json.dumps(result, indent=2, sort_keys=True))
----
=====

[.include-with-Cypher]
=====
[source, cypher, subs=attributes+]
----
CALL gds.graph.project(
  'example_graph',
  'Page',
  'LINKS',
  {
    relationshipProperties: 'weight'
  }
)
----
=====

[.include-with-Python-driver]
=====
[source, python, subs=attributes+]
----
# Cypher query
create_example_graph_in_memory_query = """
CALL gds.graph.project(
  'example_graph',
  'Page',
  'LINKS',
  {
    relationshipProperties: 'weight'
  }
)
"""

# Create driver session
with driver.session() as session:
  # Run query
  result = session.run(create_example_graph_in_memory_query).data()
  # Prettify the first result
  print(json.dumps(result[0], indent=2, sort_keys=True))
----
=====
====

== Execution Modes

There are 5 execution modes when running production tier algorithms and each of them also provide a way to estimate or get stats about the data.

* Stats
* Stream
* Mutate
* Write
* Estimate

Below we'll show an example code snippet with PageRank to show the first four execution modes, teaching you when to consider using each mode. The Estimate mode is explained in detail in the xref:aurads/tutorials/memory-estimation.adoc[] section.

=== Stats

When running an algorithm in stats mode, youâ€™ll be returned a single row containing a summary of the algorithm statistics like counts or percentile distributions.

Running the algorithm in Stats mode does not mutate the in-memory graph so it can be useful for evaluating the algorithm performance.

https://neo4j.com/docs/graph-data-science/current/common-usage/running-algos/#running-algos-stats[]

[.tabbed-example]
====
[.include-with-GDS-client]
=====
[source, python, subs=attributes+]
----
stats = gds.pageRank.stats(
  g,
  maxIterations=20,
  dampingFactor=0.85
)

print(json.dumps(stats, indent=2, sort_keys=True))
----
=====

[.include-with-Cypher]
=====
[source, cypher, subs=attributes+]
----
CALL gds.pageRank.stats(
  'example-graph', 
  {maxIterations: 20, dampingFactor: 0.85}
)
YIELD ranIterations,
  didConverge,
  preProcessingMillis,
  computeMillis,
  postProcessingMillis,
  centralityDistribution,
  configuration
RETURN *
----
=====

[.include-with-Python-driver]
=====
[source, python, subs=attributes+]
----
# Cypher query
page_rank_stats_example_graph_query = """
CALL gds.pageRank.stats(
  'example-graph', 
  {maxIterations: 20, dampingFactor: 0.85}
)
YIELD ranIterations,
  didConverge,
  preProcessingMillis,
  computeMillis,
  postProcessingMillis,
  centralityDistribution,
  configuration
RETURN *
"""

# Create driver session
with driver.session() as session:
  # Run query
  results = session.run(page_rank_stats_example_graph_query).data()
  # Prettify the first result
  print(json.dumps(results[0], indent=2, sort_keys=True))
----
=====
====

The above stats gave us the time it would take to compute the algorithm (`computeMillis`) along with other details like the `centralityDistribution` and our configuration parameters which contain bits like the concurrency.

=== Stream

https://neo4j.com/docs/graph-data-science/current/common-usage/running-algos/#running-algos-stream[Stream] mode will return the results of an algorithm once it has completed. This is similar to how standard Cypher reading queries operate.

With our PageRank example, we'll be returned a node ID and the computed PageRank score. If the data is already stored within the instance, you can use the https://neo4j.com/docs/graph-data-science/current/management-ops/utility-functions/#utility-functions-node-path[gds.util.asNode] procedure to get the node from the internal node ID

However, because Algorithms can be long running and the reliability of your internet connections depends on lots of factors, it is advised that you consider the use of Mutate and Write modes instead to persist your results so that you can return to them.

[.tabbed-example]
====
[.include-with-GDS-client]
=====
[source, python, subs=attributes+]
----
results = gds.pageRank.stream(
  g, 
  maxIterations=20, 
  dampingFactor=0.85
)

print(json.dumps(results, indent=2, sort_keys=True))
----
=====

[.include-with-Cypher]
=====
[source, cypher, subs=attributes+]
----
CALL gds.pageRank.stream(
  'example-graph', 
  {maxIterations: 20, dampingFactor: 0.85}
)
YIELD nodeId, score
RETURN *
----
=====

[.include-with-Python-driver]
=====
[source, python, subs=attributes+]
----
# Cypher query to just get internal node ID and score
page_rank_stream_example_graph_query = """
CALL gds.pageRank.stream(
  'example-graph', 
  {maxIterations: 20, dampingFactor: 0.85}
)
YIELD nodeId, score
RETURN *
"""

# Create driver session
with driver.session() as session:
  # Run query
  results = session.run(page_rank_stream_example_graph_query).data()
  # Prettify the results
  print(json.dumps(results, indent=2, sort_keys=True))
----
=====
====

=== Mutate

The https://neo4j.com/docs/graph-data-science/current/common-usage/running-algos/#running-algos-mutate[Mutate] execution mode operates on the in-memory graph and updates it with a new property that can be specified with the mutateProperty configuration. The mutateProperty value must not exist in the in-memory graph beforehand.

Mutate mode is great for chaining many algorithms together which rely on the results on a previous algorithm.

In the case of PageRank, we are returned a score for each node.

The example below, will add a new property called pageRankScore to each node in our in-memory graph with the score returned from the algorithm.

[.tabbed-example]
====
[.include-with-GDS-client]
=====
[source, python, subs=attributes+]
----
result = gds.pageRank.mutate(
  g,
  mutateProperty="pageRankScore", 
  maxIterations=20, 
  dampingFactor=0.85
)

print(json.dumps(result, indent=2, sort_keys=True))
----
=====

[.include-with-Cypher]
=====
[source, cypher, subs=attributes+]
----
CALL gds.pageRank.mutate(
  'example-graph', 
  {mutateProperty: 'pageRankScore', maxIterations: 20, dampingFactor: 0.85}
)
YIELD nodePropertiesWritten, ranIterations
RETURN *
----
=====

[.include-with-Python-driver]
=====
[source, python, subs=attributes+]
----
# Cypher query to just get mutate the graph
page_rank_mutate_example_graph_query = """
CALL gds.pageRank.mutate(
  'example-graph', 
  {mutateProperty: 'pageRankScore', maxIterations: 20, dampingFactor: 0.85}
)
YIELD nodePropertiesWritten, ranIterations
RETURN *
"""

# Create driver session
with driver.session() as session:
  # Run query
  results = session.run(page_rank_mutate_example_graph_query).data()
  # Prettify the results
  print(json.dumps(results, indent=2, sort_keys=True))
----
=====
====

=== Write

https://neo4j.com/docs/graph-data-science/current/common-usage/running-algos/#running-algos-write[Write] mode will write the results of the algorithm computation back to the Neo4j database. This enables you to be able to query the results with Cypher.

Different algorithms may write different entities (nodes, relationships or properties). For example, PageRank will write node properties, Node Similarity will write new relationships.

In order for the results from a write mode computation to be used by another algorithm, a new in-memory graph must be created from the Neo4j database.

[.tabbed-example]
====
[.include-with-GDS-client]
=====
[source, python, subs=attributes+]
----
result = gds.pageRank.write(
  g, 
  writeProperty="pageRankScore",
  maxIterations=20, 
  dampingFactor=0.85
)

print(json.dumps(result, indent=2, sort_keys=True))
----
=====

[.include-with-Cypher]
=====
[source, cypher, subs=attributes+]
----
CALL gds.pageRank.write(
  'example-graph', 
  {writeProperty: 'pageRankScore', maxIterations: 20, dampingFactor: 0.85}
)
YIELD nodePropertiesWritten, ranIterations
RETURN *
----
=====

[.include-with-Python-driver]
=====
[source, python, subs=attributes+]
----
# Cypher query to write the graph
page_rank_write_example_graph_query = """
CALL gds.pageRank.write(
  'example-graph', 
  {writeProperty: 'pageRankScore', maxIterations: 20, dampingFactor: 0.85}
)
YIELD nodePropertiesWritten, ranIterations
RETURN *
"""

# Create driver session
with driver.session() as session:
  # Run query
  results = session.run(page_rank_write_example_graph_query).data()
  # Prettify the results
  print(json.dumps(results, indent=2, sort_keys=True))
----
=====
====

== Clean-up the tutorial

To drop the example in-memory graph we created previously, you can use the https://neo4j.com/docs/graph-data-science/current/management-ops/graph-catalog-ops/#graph-catalog-ops[gds.graph.drop] procedure and specify the name of the graph we created (example-graph).

[.tabbed-example]
====
[.include-with-GDS-client]
=====
[source, python, subs=attributes+]
----
delete_example_graph = """
MATCH (n1)-[r]-(n2)
DELETE r, n1
"""

result = gds.graph.drop(g)
print(json.dumps(result, indent=2, sort_keys=True, default=default))

gds.run_cypher(delete_example_graph)
----
=====

[.include-with-Cypher]
=====
[source, cypher, subs=attributes+]
----
CALL gds.graph.drop('example-graph')
----
=====

[.include-with-Python-driver]
=====
[source, python, subs=attributes+]
----
delete_example_in_memory_graph_query = """
CALL gds.graph.drop('example-graph')
"""

delete_example_graph = """
MATCH (n1)-[r]-(n2)
DELETE r, n1
"""

with driver.session() as session:
  # Delete in-memory graph
  result = session.run(delete_example_in_memory_graph_query).data()
  # Prettify the result
  print(json.dumps(results, indent=2, sort_keys=True, default=default))
    
  # Delete data from Neo4j
  result = session.run(delete_example_graph).data()
  # Prettify the result
  print(json.dumps(results, indent=2, sort_keys=True, default=default))
----
=====
====
