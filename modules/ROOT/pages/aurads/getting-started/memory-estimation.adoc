[[memory-estimation]]
= Memory estimation
:description: This page describes how to use estimate the needed memory.

https://colab.research.google.com/drive/1Y5bZI61H0NuH8GCU9vpzR5Wk9Z4-r7hd?usp=sharing[image:colab.svg[Colab,24] Play in Google Colab]

This brief tutorial can be followed along within Google Colab which is based on Jupyter notebooks.

In this tutorial, we will show you how to use the memory estimator for algorithms and how to resize your instance if needed in order to run your desired algorithm.

For more information about the https://neo4j.com/docs/graph-data-science/current/common-usage/memory-estimation/[Memory Estimation] head over to the Neo4j Graph Data Science Library manual.

== Driver Setup

For more information about getting started with the python driver, check out the previous tutorial https://colab.research.google.com/drive/10XK5_fyNURb1u_gvD_lkt7qQvIxzAhnJ#scrollTo=lLi0tbsaaWnH[here]

[source, python]
----
pip install neo4j
----

[source, python]
----
# Driver import
from neo4j import GraphDatabase

# We'll use the json.dumps function later to prettify some results
import json

# Connection Details
# Aura queries use an encrypted connection using the "neo4j+s" URI scheme
AURA_CONNECTION_URI = "neo4j+s://xxxxxxxx.databases.neo4j.io"
AURA_USERNAME = "neo4j"
#AURA_PASSWORD = ""

# Driver Instantiation
driver = GraphDatabase.driver(AURA_CONNECTION_URI, auth=(AURA_USERNAME, AURA_PASSWORD))
----

== Example Graph

We're going to use the database you have specified above to create an in-memory graph. We'll delete this data later on in the tutorial.

We will use the graph generation function within the GDS Library to generate a random in-memory graph.

Our graph is going to be nodes with the label `1000000_Nodes` with a relationship of `POWER_LAW`

`(:1000000_Nodes)-[:POWER_LAW]->(:1000000_Nodes)`

You can read more about the https://neo4j.com/docs/graph-data-science/current/alpha-algorithms/graph-generation/#graph-generation[Graph Generation] procedure. This may take a minute or so to run.

[source, python]
----
# Cypher Query
create_example_graph_query = """
CALL gds.beta.graph.generate("example-graph", 100000000, 3, {relationshipDistribution: 'POWER_LAW'})
YIELD name, nodes, relationships, generateMillis, relationshipSeed, averageDegree, relationshipDistribution, relationshipProperty
RETURN *
"""

# Create driver session to the database
with driver.session() as session:
  # Run query
  result = session.run(create_example_graph_query).data()
  # prettify the first result
  print(json.dumps(result[0], indent=2, sort_keys=True))
----

== Estimate

It can be useful to get a memory estimation to understand the impact an algorithm will have (running on the in-memory graph you provided given the available compute resources), before running any of the `Stream`, `Mutate` or `Write` execution modes.

The Graph Data Science Library does have guard-rails built in, so if an algorithm uses more than the RAM & CPU you have available you will get an exception returned.

If you need more RAM & CPU, you can resize your GDS instance within the Neo4j Aura Console under the Settings tab under the database details.

Below is an example of getting a memory estimation for if we wanted to mutate the in-memory graph with the results of PageRank and hitting the guard rails on an 8GB instance.

[source, python]
----
# Cypher Query
page_rank_mutate_estimate_example_graph_query = """
CALL gds.labelPropagation.mutate.estimate("example-graph", { mutateProperty: 'communityID' } )
YIELD nodeCount,
    relationshipCount,
    bytesMin,
    bytesMax,
    requiredMemory
RETURN *
"""

# Create driver session to the database
with driver.session() as session:
  # Run query
  results = session.run(page_rank_mutate_estimate_example_graph_query).data()
  # prettify the first result
  print(json.dumps(results[0], indent=2, sort_keys=True))
----

[source, python]
----
# Lets try to run the query to hit the memory guard

# Cypher Query
page_rank_mutate_estimate_example_graph_query = """
CALL gds.labelPropagation.mutate("example-graph", { mutateProperty: 'communityID' } )
YIELD createMillis,
 computeMillis,
 mutateMillis,
 postProcessingMillis,
 nodePropertiesWritten,
 communityCount,
 ranIterations,
 didConverge,
 communityDistribution,
 configuration
RETURN *
"""

# Create driver session to the database
with driver.session() as session:
  # Run query
  results = session.run(page_rank_mutate_estimate_example_graph_query).data()
  # prettify the first result
  print(json.dumps(results[0], indent=2, sort_keys=True))
----

== Resizing your instance

Resizing your instance will incur a short amount of downtime.

Click the name of your instance on the home to get to the database details.

image::resize1.png[title="Resize 1"]

Under the settings tab, after clicking the resize option you can select a new instance size which matches the required memory needed given by the previous estimation.

image::resize2.png[title="Resize 2"]

== Clean-up the tutorial

To drop the example in-memory graph we created previously, you can use the https://neo4j.com/docs/graph-data-science/current/management-ops/graph-catalog-ops/#graph-catalog-ops[gds.graph.drop] procedure and specify the name of the graph we created (example-graph).

[source, python]
----
delete_example_in_memory_graph_query = """
CALL gds.graph.drop("example-graph")
"""

with driver.session() as session:
  # Run query
  results = session.run(delete_example_in_memory_graph_query).data()

  # for each result prettify the result
  for result in results:
    print(json.dumps(result, indent=2, sort_keys=True))
----
