[[auradb-performance]]
= Improving the performance

After completing the initial implementation, it is common to search for ways to improve the performance of your workload.
Here you can find a number of options that can be considered for operating your application on Neo4j AuraDB.

== Review queries and model

One first action that you can take is reviewing and listing all your Cypher queries.
The best starting point is to have a good understanding of the sequence and frequency of the Cypher queries submitted.

Additionally, if your queries are somehow generated by a framework, it is essential that you log the Cypher as it is often the starting point to make changes and review what works best.

You can also profile the Cypher by producing an `EXPLAIN` and `PROFILE` plan by prepending the keywords to your query, so you get the association plan.
Read more about profiling a query link:https://neo4j.com/docs/cypher-manual/current/query-tuning/#how-do-i-profile-a-query[here].

[NOTE]
====
When using `PROFILE` you may need to run it multiple times in order to get the optimal value.
The first time the query runs, it gets a full cycle of evaluation, planning, and interpreting before making its way into the query cache.
Once in the cache, the subsequent execution time will improve.
Furthermore, always use parameters instead of literal values to benefit from the cache.
====

Read more about link:https://neo4j.com/docs/cypher-manual/current/execution-plans/[execution plans] and see this detailed guide for the steps on link:https://aura.support.neo4j.com/hc/en-us/articles/6638160188691[how to capture the execution plans]

To best interpret the output of your execution plan, it is recommended that you get familiar with the terms used on it.
See link:https://neo4j.com/docs/cypher-manual/current/execution-plans/operator-summary/[this summary of execution plan operators] for more information.

== Index specification

As your data volume grows, it is important to define constraints and indexes in order to achieve the best performance for your queries.
For that, the runtime engine will need to evaluate the cost associated with a query and, to get the best estimations, it will rely on already existing indexes.
This will likely show whether an index is missing from the execution plan and which one is it.
Though in some circunstances it might look like an index is not available or possible, it may also make sense to reconsider the model and create an intermediate node or another relationship type just to leverage it.

See link:https://neo4j.com/docs/cypher-manual/current/query-tuning/indexes/[this page] for a more comprehensive explanation of indexes.

[NOTE]
====
You can also fine-tune the usage of an index in your query by leveraging it with the link:https://neo4j.com/docs/cypher-manual/current/query-tuning/using/[`USING`] clause.
====

== Review metrics during the workload and find the right instance size

With Aura, you can keep an eye on some key metrics to see which resource constraints your instance may be experiencing.
These include:

* **CPU Usage:** A high load is generally expected when you have a computational heavy workload.
In case your query is not complex, another common reason may be that the CPU is consumed with memory management.
* **Out of memory errors:** Queries that handle or process too much data may lead to OOM.
There are many built-in protections, but not everything can be constrained.
* **Heap usage (Enterprise only)**: This helps you understand if the heap is exhausting vs the off-heap memory.
* **Page cache evictions:** High values indicate that the memory is used intensely.
* **Garbage collection time:** This will indicate how hard the garbage collector works to allocate or free memory, thus allowing the execution of your queries.
When this metric gets high, you should also see a higher CPU load.

At this stage, if the key metrics are too high, you may want to reconsider the instance sizing.
A resize operation doees not cause any downtime, and you would only pay for what you use.

[TIP]
====
You should always size your instance against your workload activity peaks.
====

== Consider concurrency

Sometimes individual queries may be optimized on their own and run fine, but the sheer volume and concurrency of operations can overwhelm your AuraDB instance.

To review what is running at any given time (this makes particular sense if you have a long-running query), you can use these statements and list what is running:

* link:https://neo4j.com/docs/cypher-manual/currentclauses/transaction-clauses/#query-listing-transactions[`SHOW TRANSACTIONS`]
* link:https://neo4j.com/docs/operations-manual/current/reference/procedures/#procedure_dbms_listqueries[`CALL dbms.listQueries()`]

== Runtime engine and Cypher version

The execution plan should show you the runtime that is selected for the execution of your query.
Usually, the planner makes the right decision, but it may be worth checking at times if the other runtimes do not perform better.
Read more about link:https://neo4j.com/docs/cypher-manual/current/query-tuning/#cypher-runtime[these differences].

To invoke the use of a given runtime forcibly, prepend your Cypher statement with:

* `CYPHER runtime=pipelined` for pipelined runtime
* `CYPHER runtime=slotted` for slotted runtime
* `CYPHER runtime=interpreted` for interpreted runtime

If you have a Cypher pattern that is not performing without error, it could as well be running on a prior Cypher version.
You can control the version used to interpret your queries by using link:https://neo4j.com/docs/cypher-manual/current/query-tuning/#cypher-version[these options].

== Network and the cost of the round-trip

With Aura, it is essential to consider the best cloud in your region as the physical distance is a direct factor in the achievable network latency.
You can find out more about this by reading link:https://medium.com/@sachinkagarwal/public-cloud-inter-region-network-latency-as-heat-maps-134e22a5ff19[this article].

When some event causes any network disruption between your application and Aura, you would be affected by round-trip network latency to re-submit a query.
With Aura, this is particularly important because you will need to be using transaction functions in

* link:https://neo4j.com/docs/python-manual/current/session-api/#python-driver-simple-transaction-fn[Python]
* link:https://neo4j.com/docs/dotnet-manual/current/session-api/configuration/#dotnet-driver-simple-transaction-fn[.NET]
* link:https://neo4j.com/docs/go-manual/current/session-api/#go-driver-simple-transaction-fn[Go]
* link:https://neo4j.com/docs/java-manual/current/session-api/#java-driver-simple-transaction-fn[Java]
* link:https://neo4j.com/docs/javascript-manual/current/session-api/configuration/#js-driver-async-transaction-fn[JavaScript]
